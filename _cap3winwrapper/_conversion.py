import os
import glob
from Bio import SeqIO
import re

def _design2paths(dictDes,pathToReads):
    """
    Matches entries in a read design dictionary (generated by _read_design) to
    .ab1 sequence files and folders in a directory.

    dictDes: the design dictionary, in which keys named TEMPLATE return a list
        of entries in the form RUN_READ:FIRST-LAST
    pathToReads: the directory to search

    Returns:
    * A dictionary in which each key TEMPLATE returns a list of paths to
        .ab1 files.
    * A dictionary in which each key TEMPLATE returns a list of tuples, which
        give the 0-indexed range of each read sequence to be analyzed. The 
        tuple entry (0,0) indicates that the entire sequence should be 
        analyzed.
    """

    lTemp=list(dictDes.keys())
    dictPaths={}
    dictRanges={}
    for temp in lTemp:
        lPaths=[]
        lRanges=[]
        for read in dictDes[temp]:
            readSpl=read.split("_",1) # parse read name at the first _
            if len(readSpl)>1:
                readSpl=[readSpl[0]]+re.split(":|-",readSpl[1]) # parse range
            if len(readSpl)!=2 and len(readSpl)!=4:
                raise ValueError(
                        "".join(["Read name ",read," must match the format ",\
                                "RUN_READ or RUN_READ:FIRST-LAST"]))
            pathPattern=os.path.join(
                    pathToReads,
                    "".join(["*",readSpl[0],"*"]),
                    "".join(["*",readSpl[1],"*",".ab1"]))
            pathExp=glob.glob(pathPattern)
            if len(pathExp)!=1:
                if len(pathExp)==0:
                    raise ValueError(
                            "".join(["Read ",read," does not match a file"]))
                elif len(pathExp)>1:
                    raise ValueError(
                            "".join(["Read ",read," matches multiple files"]))
            lPaths.append(pathExp[0])
            if len(readSpl)==4:
                lRanges.append((int(readSpl[2])-1,int(readSpl[3])))
            else:
                lRanges.append((0,0))
                
        dictPaths[temp]=lPaths
        dictRanges[temp]=lRanges

    return dictPaths,dictRanges

def _ab2faqual(dictDes,dictPaths,dictRanges):
    """
    Using a design dictionary and a dictionary of .ab1 paths, constructs, for
    each .ab1 file, a .fa file (without file extension) and .qual file whose
    file name matches the dictionary key and whose sequence names match those
    in the design dictionary.

    dictDes: the design dictionary, in which keys named TEMPLATE return a list
        of entries in the form RUN_READ
    dictPaths: the paths dictionary, in which keys named TEMPLATE return a
        list of file paths in the same order as dictDes
    dictRanges: the ranges dictionary, in which keys named TEMPLATE return a
        list of tuples giving the sequence range to be selected from each
        read. Note that ranges are 0-indexed.

    Writes the .fa and .qual files to the working directory.
    """

    lTemp=list(dictDes.keys())
    for temp in lTemp:

        # Read in all the .ab1 files sequenced from the template
        lSeq=list()
        for i in range(len(dictDes[temp])):
            if dictRanges[temp][i]!=(0,0):
                sl=slice(*dictRanges[temp][i])
                seq=SeqIO.read(dictPaths[temp][i],"abi")[sl]
            else:
                seq=SeqIO.read(dictPaths[temp][i],"abi")
            lSeq.append(seq)
            lSeq[i].id=dictDes[temp][i]

        # Write the .fa and .qual files using UNIX-style line endings
        fa=open(temp,mode="w",newline="\n")
        SeqIO.write(lSeq,fa,"fasta")
        fa.close()
        qual=open("".join([temp,".qual"]),mode="w",newline="\n")
        SeqIO.write(lSeq,qual,"qual")
        qual.close()
